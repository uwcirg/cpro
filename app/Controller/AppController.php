<?php
/**
    * App Controller, father of all controllers
    * 
    * This controller defines application-wide features used in multiple 
    * controllers.
    * Functions defined here and methods called in beforeFilter are inherited in
    * other controllers and available there. 
    *
    * See documentation below for app-wide systems: Auth, Tabs
    * 
    * Copyright 2013 University of Washington, School of Nursing.
    * http://opensource.org/licenses/BSD-3-Clause 
    *
*/
App::uses('Controller', 'Controller');

class AppController extends Controller
{
   /* seconds of inactivity before a session needs to be invalidated: 
      5 minutes for a Kiosk, 20 minutes otherwise
    */
    const KIOSK_TIMEOUT = 300;
    const KIOSK_STAFF_TIMEOUT = 300;
    const NONKIOSK_TIMEOUT = 1200;

    /**
      Name of a session variable that describes why a user has been logged out.
     */
    const LOGOUT_FLASH = 'LOGOUT_FLASH';

    const SESSION_TIMEOUT_MESSAGE = 'Your session has timed out.';

    const PATIENT_INELIGIBLE_MSG_ROOT = 'Ineligible for ';
    var $PATIENT_INELIGIBLE_MSG;

    var $LOGIN_FLASH_MSGS = array();
 
    /**
      Name of a session variable indicating that 
     */
    const PATIENT_INELIGIBLE = 'PATIENT_INELIGIBLE';

    /**
     * Name of a session variable that holds a key to hopefully thwart 
     * cross-site request forgeries.  
     */
    const ID_KEY = 'AppController_id';

    /**
     */
    const STAFF_LOGIN_AS_PATIENT = 'STAFF_LOGIN_AS_PATIENT';

    /**
     * Name of a session variable that holds the id of a patient the current
     * user is taking a survey as
     */
    const TAKING_SURVEY_AS = 'takingSurveyAs';

    /**
     * Name of a session variable that holds the last time we think the
     * user did anything.
     */
    const TIMEOUT_KEY = 'timeout';

    /** Variable that says whether we are running on the test database */
    protected $testInstance;

    /**
     * Cake version of the session variable to match ID_KEY
     */
    /* This name works for use in Cake form->hidden function calls, 
       because Cake parses the name and removes the period
     */
    const CAKEID_KEY = 'AppController.AppController_id';

    /** Name of a form variable that should match ID_KEY. 
     */
    /* This should be what Cake turns the ID_KEY into.  Useful for
     * forms that aren't generated by Cake
     */
    const FORMID_KEY = 'data[AppController][AppController_id]';

    /** Name of the action where a user changes their own password */
    const CHANGE_PASSWORD_ACTION = 'changePasswordOfAuthdUser';

    /** URL for the action where a user changes their own password */
    const CHANGE_PASSWORD_URL = '/users/changePasswordOfAuthdUser';

    /** Format for dates in log messages */
    const LOG_FORMAT = 'Y-m-d H:i:s';

    var $components = array("Auth", "DhairAuth", "DhairLogging", "Cookie", "RequestHandler", "Session", "TabFilter", "DhairDateTime");

    //var $uses = array('Log', "Inflector", "User", "Patient", "Associate");
    var $uses = array('Log', "Inflector", "User", "Patient");
    var $helpers = array("Html", "Form", "TabHtml", "Js", "Time", 
                            "Minify", "Session");

    /**
    * This is the MVC that almost every DHAIR instance is likely to need. 
    */
    var $modelsDhairCore = 
        array('users', 'patients', 'clinics', 'sites', 'notes', 'consents', 
                'answers', 'surveys', 'conditions', 'options', 'questions', 'pages', 'questionnaires', 'projects', 'project_questionnaires', 
                'items', 'subscales', 'scales', 
                'survey_sessions',  
                'session_items', 'session_subscales', 'session_scales',
                'admin', //controller, not model 
                'data_access', 'medical_records', 
                'acos', 'aros', 'aros_acos', 'user_acl_leafs', 'logs',
                'alerts');

    var $modelsForThisDhairInstance; 

    var $quickLinks = array();
 
    var $jsAddnsToLayout = array();

    var $user;
    // id of the authenticated user
    // TODO replace w/ SessionComponent::read('Auth.User.id')
    var $authd_user_id; 
    // is the logged in user staff? used for google analytics.
    var $is_staff;
    // if the user is a patient, this is the patient record.
    // else if the user is a staff user taking a survey on a patient's behalf,
    //      then this is that patient's record.
    var $patient;
    //var $session_link; // array(link label, target url relative) FIXME NO LONGER USED, RIGHT?
  
    var $i18nLanguages = array();
    var $i18nPostfix = '';


    function __construct($request = null, $response = null){
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "()", LOG_DEBUG);

        $this->modelsForThisDhairInstance = 
                array_merge(Configure::read('modelsInstallSpecific'), 
                                $this->modelsDhairCore);

        $PATIENT_INELIGIBLE_MSG 
            = self::PATIENT_INELIGIBLE_MSG_ROOT . SHORT_TITLE;
        $LOGIN_FLASH_MSGS = array(self::SESSION_TIMEOUT_MESSAGE, 
                                $PATIENT_INELIGIBLE_MSG);

        parent::__construct($request, $response);
    }

    /**
     *
     */
    function constructClasses(){
//        $this->log(get_class($this) . " (fxn as defined in AppController) " . __FUNCTION__ . "()", LOG_DEBUG);

        $instanceModelOverrides =
            Configure::read('instanceModelOverrides');
        foreach($instanceModelOverrides as $key => $modelName){
//            $this->log(get_class($this) . " (fxn as defined in AppController) " . __FUNCTION__ . "(), subclassing $modelName", LOG_DEBUG);
            //eg "Patient"
            //$baseModelName = $this->Inflector->humanize($modelName);
            $baseModelName = Inflector::camelize($modelName);
//            $this->log("baseModelName: " . $baseModelName, LOG_DEBUG);
            //eg "PatientEsrac"
            $subclassModelName = 
                $baseModelName .
                //$this->Inflector->humanize(INSTANCE_ID);
                Inflector::humanize(INSTANCE_ID);
//            $this->log("subclassModelName: " . $subclassModelName, LOG_DEBUG);
            App::uses($subclassModelName, 'Model');
            //App::import('Model', $subclassModelName);
            $this->{$baseModelName} = new $subclassModelName;
            //$this->Patient->constructClasses();
//            $this->log(get_class($this) . " (fxn as defined in AppController) " . __FUNCTION__ . "(), done subclassing $modelName", LOG_DEBUG);
        }

        $instanceComponentOverrides =
            Configure::read('instanceComponentOverrides');
        foreach($instanceComponentOverrides as $componentName){
//            $this->log(get_class($this) . " (fxn as defined in AppController) " . __FUNCTION__ . "(), subclassing $componentName", LOG_DEBUG);
            //eg "TabFilter"
            //$baseComponentName = $this->Inflector->humanize($componentName);
            $baseComponentName = Inflector::humanize($componentName);
            //eg "TabFilterP3pmazzone"
            $subclassComponentName = 
                $baseComponentName .
                //$this->Inflector->humanize(INSTANCE_ID); 
                Inflector::humanize(INSTANCE_ID); 

            /**$this->components[$baseComponentName] = 
                array('classname' => $subclassComponentName);*/

            $this->components[] = $subclassComponentName;
            App::uses($subclassComponentName, 'Controller/Component');

            //$subWComponentStringInName = $subclassComponentName."Component";

            //$this->$baseComponentName = new $subWComponentStringInName($this->Components);
            //$this->$baseComponentName = new $subclassComponentName($this->Components);
            //$this->$baseComponentName = $this->Components->load($subclassComponentName);

            //App::import('Component', $subclassComponentName);
            //$subclassComponent = new $subclassComponentClassName;
            /*$subclassComponent->initialize($this);
            $subclassComponent->startup($this);
            $this->{$baseComponentName} = $subclassComponent;*/
            //$this->log("$baseComponentName: " . print_r($this->{$baseComponentName}, true), LOG_DEBUG);
//            $this->log(get_class($this) . " (fxn as defined in AppController) " . __FUNCTION__ . "(), done subclassing $componentName", LOG_DEBUG);
        }
       
        // include instance-specific component eg 'Paintracker' 
        $instanceComponentNameFile 
            = APP . 'Controller' . DS . 'Component' 
                . DS . Inflector::classify(INSTANCE_ID) . 'Component.php';
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(), next is looking for file $instanceComponentNameFile", LOG_DEBUG);
        if (file_exists($instanceComponentNameFile)){
            $this->components[] = Inflector::humanize(INSTANCE_ID);
        }

//        $this->log(get_class($this) . " (fxn as defined in AppController) " . __FUNCTION__ . "(), next is parent::constructClasses", LOG_DEBUG);
        parent::constructClasses();
//        $this->log(get_class($this) . " (fxn as defined in AppController) " . __FUNCTION__ . "(), done w/ parent::constructClasses", LOG_DEBUG);

    }// function constructClasses(){

    /**
     *
    function beforeRedirect($controller, $url, $status=null, $exit=true)
    {
        $this->log(__CLASS__ . "." . __FUNCTION__ . "(controller:$controller, url:$url, status:$status, exit:$exit) for " . $this->request->params['controller'] . '/' . $this->request->params['action'] , LOG_DEBUG);

        parent::beforeRedirect($controller, $url, $status, $exit);
    }
     */


    /**
     *
     */
    function beforeFilter()
    {
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'], LOG_DEBUG);
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'] . '; here are the request data: ' . print_r($this->request->data, true), LOG_DEBUG);
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'] /**. '; here are the cookies: ' . print_r($_COOKIE, true)*/, LOG_DEBUG);

        if (Configure::read('systemStatus') == SYSTEM_DOWN){
            if (
                !in_array(
                    $this->request->params['action'],
                    array('about', 'help', 'login', 'logout')
                )
            ){
                $this->redirect('/users/logout');
                $this->Auth->logout();
                $this->flash(SYSTEM_DOWN_MESSAGE, '/users/about', 10);
            }
        }

        // because the suhosin patch breaks the standard cipher encrypt/decrypt
        $this->Cookie->type('rijndael');
        $this->Cookie->key = Configure::read('Security.key');
    
        if (!(($this->request->params['action'] == 'logout') &&
            ($this->request->params['controller'] == 'users'))) {
            $this->checkForTimeout();
        }
 
        if (($this->request->params['action'] != 'download') &&
            ($this->request->params['controller'] != 'data_access')) {
            /** note that the next line simply adds headers to the response,
            *       instructing the browser to not cache
            */
            $this->disableCache();
        }


//        $this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'] . ", next is if Auth->user(id)", LOG_DEBUG);
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(), heres Auth->redirectUrl():" . $this->Auth->redirectUrl(), LOG_DEBUG);

//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(), heres Session read Auth->redirect:" . $this->Session->read('Auth.redirect'), LOG_DEBUG);

        if($this->Auth->user('id')) {

//            $this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'] . ", yes to if Auth->user(id)", LOG_DEBUG);
            // Logging
            $paramsToAction = strip_tags(implode(",", $this->request->params['pass']));
            $paramsToAction = 
                $this->_cleanParamsForExternalResourceUrlLogging(
                        $paramsToAction);
            $log['Log'] = array(
                "user_id"     =>  $this->Auth->user('id'),
                "controller"  =>  strip_tags($this->request->params['controller']),
                "action"      =>  strip_tags($this->request->params['action']),
                //"params"      =>  strip_tags(implode(",", $this->request->params['pass'])),
                "params"      =>  $paramsToAction,
                "time"        =>  gmdate("Y-m-d G-i-s"),
                "ip_address" => $this->request->clientIp(), 
                "user_agent" => $_SERVER['HTTP_USER_AGENT'] 
            );
            $this->Log->create();
            $this->Log->save($log);

            if ($this->request->params['controller'] == 'logs' &&
                $this->request->params['action'] == 'add') {
                return; // no need to process state further
            }
 
            # Set up variables only used for logged-in users:
            $this->authd_user_id = $this->Auth->user('id');
            //$this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'] . ", authd_user_id: " . $this->authd_user_id, LOG_DEBUG);
            $this->user = $this->User->findById($this->authd_user_id);

            //$this->log("thisuser: " . print_r($this->user, true), LOG_DEBUG);

            //$this->log("(IP address: " . $this->request->clientIp() . ") this user_id: " . print_r($this->authd_user_id, true), LOG_DEBUG);
            //$this->log("(IP address: " . $this->request->clientIp() . ") sessionTest before writing: " . $this->Session->read('sessionTest'), LOG_DEBUG);
            //$this->Session->write("sessionTest", $this->Auth->user('id'));
            //$this->log("(IP address: " . $this->request->clientIp() . ") sessionTest after writing: " . $this->Session->read('sessionTest'), LOG_DEBUG);

            /** 
            $userViaAuth = $this->Auth->user();
            
            $this->log("userViaAuth: " . print_r($userViaAuth, true), LOG_DEBUG);
            */
            if ($this->Session->check(self::STAFF_LOGIN_AS_PATIENT)) {

                $this->setKiosk(true);

                $dontChangePassword = 
                    $this->Session->read(self::STAFF_LOGIN_AS_PATIENT);
                if ($this->user['User']['change_pw_flag'] == 1){
                    $this->User->setPassword($this->authd_user_id, openssl_random_pseudo_bytes(8));
                    $this->Session->setFlash('The patient\'s password has been scrambled.','flash_info');
                }
            } else {
                $dontChangePassword = false;
            }
            /* if the user is supposed to change their password, redirect them
               to that URL (unless they're already going there) */
            if (!$this->DhairAuth->requestIsForAllowableAction() &&
                $this->user['User']['change_pw_flag'] &&
                !$dontChangePassword &&
                !('/' . $this->request->url == self::CHANGE_PASSWORD_URL))
            {
//                $this->log(__CLASS__ . '->' . __FUNCTION__ . '(), change_pw_flag set,,reditrecting to ' . self::CHANGE_PASSWORD_URL, LOG_DEBUG);
                $this->Session->setFlash('You must change your password.','flash_error');
                $this->redirect(self::CHANGE_PASSWORD_URL);
            }

            $this->patient = 
                $this->Patient->find('first', array('recursive'=>1,
                    'conditions' => array('User.id' => $this->authd_user_id)));
            //$this->patient = $this->_findPatientViaSessionVar($this->authd_user_id);

            if(!empty($this->patient)) {

//                $this->log(__CLASS__ . '->' . __FUNCTION__ . '(), patient not empty. ' . print_r($this->patient, true), LOG_DEBUG);

                $this->is_staff = false;
                if (
                    defined('ELIGIBILITY_WORKFLOW') and
                    ELIGIBILITY_WORKFLOW and (
                        $this->patient['Patient']['eligible_flag'] != '1' or
                        $this->patient['Patient']['off_study_status'] == Patient::OSINELIGIBLE
                    ) and
                    $this->request->params['action'] != 'logout'
                ){

                    // FIXME This won't work because the Session will be whacked at logout.
                    // TODO write $flashMsg to cookie instead
                    /**$this->Session->write(
                        self::LOGOUT_FLASH, 
                        $this->PATIENT_INELIGIBLE_MSG . SHORT_TITLE);*/

//                    $this->log(__CLASS__ . '->' . __FUNCTION__ . '(), patient ineligible, redirecting to users/logout', LOG_DEBUG);
                    $this->Cookie->write('Ineligible', 'true');
                    $this->redirect('/users/logout');
                }
            }
            else {
                $this->is_staff = true;
                $this->Auth->loginRedirect = array(
                    'controller' => 'patients', 'action' => 'viewAll');
            }
//            $this->log(__CLASS__ . "." . __FUNCTION__ . "(), is_staff: " . $this->is_staff, LOG_DEBUG);

            $staffFocusedOnPatient;
                
            if ($this->request->params['controller'] == 'surveys' &&
                    $this->Session->check(self::TAKING_SURVEY_AS)){
                $staffFocusedOnPatient = 
                            $this->Session->read(self::TAKING_SURVEY_AS);
            }
            elseif (
                $this->request->params['controller'] == 'patients' and (
                    in_array($this->request->params['action'], array(
                        'takeSurveyAs',
                        'medications',
                        'dashboard',
                    )) or (
                        $this->request->params['action'] == 'edit' and
                        // Don't set for AJAX POST
                        // We need GET to refresh certain portions of the users/edit page
                        $this->request->is('get')
                    )

                )
            ){
                $staffFocusedOnPatient = $this->request->params['pass'][0];
            }
            if (isset($staffFocusedOnPatient)){
                $this->patient = $this->Patient->find('first', array(
                    'recursive' => 1,
                    'conditions' => array('User.id' => $staffFocusedOnPatient)
                ));
                // $f = Configure::read('tabControllerActionMap');
                // $this->log('tabControllerActionMap'.print_r($f['Patients'], true), LOG_DEBUG);
                // $this->log(__FUNCTION__ . ':Patient: '.print_r(array_keys($this->patient), true), LOG_DEBUG);
                //$this->_findPatientViaSessionVar($staffFocusedOnPatient);
            }

            if(!empty($this->patient)) {
//                $this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'] . ", this->patient not empty."/** . print_r($this->patient, true)*/, LOG_DEBUG);
                if (!$this->request->isAjax() 
                    && ($this->request->params['controller'] != 'surveys' 
                    or $this->request->params['action'] == 'new_session'
                    or $this->request->params['action'] == 'break_session')){

//                    $this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'] . ", next is analyzeCurrentApptAndSessionState(...)", LOG_DEBUG);

                    $this->Patient->analyzeCurrentApptAndSessionState($this->patient);

                    $this->set('patientProjectsStates', 
                                    $this->Patient->projectsStates);
//                    $this->log(__CLASS__ . "->" . __FUNCTION__ . "(), patientProjectsStates: " . print_r($this->Patient->projectsStates, true), LOG_DEBUG);
                }

                $this->set('patient', $this->patient);
            }
            // else $this->log("this->patient is empty", LOG_DEBUG);

            $this->set('user', $this->user);
            $this->set('clinic', $this->user["Clinic"]["name"] . $this->user["Clinic"]["id"]);
            $this->set('authorizedUser', true);

            $this->i18nPostfix = '';
            $this->i18nLanguages = Configure::read('i18nLanguages');
            if (!empty($this->i18nLanguages)
                && !$this->request->isAjax() // for performance, might need to remove later...
            ){
//                $this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'] . ", doing i18n stuff", LOG_DEBUG);
                //$this->log("user: " . print_r($this->user, true), LOG_DEBUG);

                $locale = null;
                if (
                    isset($this->user['User']['language']) and
                    $this->user['User']['language']
                )
                    $locale = $this->user['User']['language'];
                if (isset($this->user['LocaleSelection'])) {
                    $numLocSelns = count($this->user['LocaleSelection']);
                } else {
                    $numLocSelns = 0;
                }
                $storedLocale = 'en_US';
                if ($numLocSelns != 0){
                    $storedLocale = $this->user['LocaleSelection'][$numLocSelns - 1]['locale'];
                    $locale = $storedLocale;
                }

                if ($this->Session->check('Config.language'))
                    $locale = $this->Session->read('Config.language');

                if (!$locale or $locale == 'en_US')
                    $locale = 'en_US';
                else
                    $this->i18nPostfix = "_" . $locale;

                // If the language is different than the stored one, save the newest selection to the DB
                if (
                    in_array('locale_selections', Configure::read('modelsInstallSpecific')) and
                    $storedLocale and
                    $locale != $storedLocale
                ){
                    $this->loadModel('LocaleSelection');
                    $this->LocaleSelection->save(array(
                        'LocaleSelection' => array(
                            'user_id' => $this->user['User']['id'],
                            'locale' => $locale,
                            'time' => $this->DhairDateTime->usersCurrentTimeStr(),
                        )
                    ));
                }

                if (
                    !$this->Session->check('Config.language') or
                    $locale != $this->Session->read('Config.language')
                )
                    $this->Session->write('Config.language', $locale);

            } // i18nLanguages !empty && !request->isAjax
//            $this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'] . ", NOT doing i18n stuff", LOG_DEBUG);
    
            $this->set('i18nPostfix', $this->i18nPostfix);
            //Set the i18n postfix so it is visible in the models
            $this->Session->write('Config.i18nPostfix',$this->i18nPostfix);

        } else {
//            $this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'] . ", ! Auth->user(id)", LOG_DEBUG);
            $this->set('authorizedUser', false);
        }

        if (!empty($this->DhairAuth->allowedActions[$this->name])) {
            $this->Auth->allow($this->DhairAuth->allowedActions[$this->name]);
        }

        $this->set('tabControllerActionMap', 
                    Configure::read('tabControllerActionMap'));

    
        // Fail if there's a possible Cross-site Request forgery
        if ($this->DhairAuth->possibleXsrf()) {
//            $this->log(__CLASS__ . "." . __FUNCTION__ . "(), possibleXsrf: " . $this->request->params['controller'] . "/" . $this->request->params['action'], LOG_DEBUG);
            if ($this->request->isAjax()) {
//            $this->log(__CLASS__ . "." . __FUNCTION__ . "(), request->isAjax, exiting", LOG_DEBUG);
            // just fail if it's ajax
            $this->exit();
            } else {
                /* give them a generic, possibly misleading message; one can
                   get here legitimately if the session did expire */
                $this->Session->setFlash(
                    "Your session has timed out.");
//                $this->log(__CLASS__ . "." . __FUNCTION__ . "(...), " . SESSION_TIMEOUT_MESSAGE . ", redirecting to /users/", LOG_DEBUG);
                $this->redirect("/users/");  
            }
        } 

        $timeoutPeriod = 
                $this->is_staff ? 
                        self::KIOSK_STAFF_TIMEOUT : self::KIOSK_TIMEOUT;
        if (!$this->isKiosk()){
            $timeoutPeriod = self::NONKIOSK_TIMEOUT;
        }
        /**$timeoutPeriod = $this->isKiosk() ? self::KIOSK_TIMEOUT : 
                                            self::NONKIOSK_TIMEOUT;*/

        // $timeoutPeriod is in seconds, but javascript wants microseconds
        $this->set('timeout_for_layout', $timeoutPeriod * 1000);

        $configs = get_class_vars('DATABASE_CONFIG');
        $this->testInstance = 
            ($configs['default']['database'] == TEST_DB_NAME);

        if ($this->testInstance) {
            $this->testPassword = $configs['testPassword'];
        }
        $pageTitle = PAGE_TITLE;
  
        // Addind p3p here because the humanize function ended up printing it
        // as "P3p" when it should be "P3P". FIXME - I'm sure there's a better
        // way to do this.
        if ($this->request->params['controller'] == 'p3p'){
            $pageTitle = 
                $pageTitle . ' - P3P';
        }
        elseif ($this->request->params['controller'] != 'users'){
            $pageTitle = 
                $pageTitle . ' - ' . 
                $this->Inflector->humanize($this->request->params['controller']);
        }
        elseif ($this->request->params['action'] != 'index') {
            $pageTitle = 
                $pageTitle . ' - ' . 
                $this->Inflector->humanize($this->request->params['action']);
        }
        if (Configure::read('isProduction') == false){
            $pageTitle = $pageTitle . " (NON-PRODUCTION)";
        }    
        $this->set('title_for_layout', $pageTitle); // cakephp 1.3
        $this->pageTitle = $pageTitle; // cakephp 1.2

        $this->set('authd_user_id', $this->authd_user_id); 
        $this->set('is_staff', $this->is_staff);

        if ($this->Cookie->check('Ineligible'))
            $this->Session->setFlash(self::PATIENT_INELIGIBLE_MSG_ROOT . SHORT_TITLE);

//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(), for " . $this->request->params['controller'] . "/" . $this->request->params['action'] . "; returning.", LOG_DEBUG);
    } // function beforeFilter()


    /**
     *
     */
    function beforeRender(){
        if (Configure::read('systemStatus') == SYSTEM_DOWN_IMMINENT){
            $this->Session->setFlash(
                SYSTEM_DOWN_IMMINENT_MESSAGE);
        }
        elseif (Configure::read('systemStatus') == SYSTEM_DOWN){
            $this->Session->setFlash(
                SYSTEM_DOWN_MESSAGE);
        }
        //$this->DhairLogging->logArrayContents($this->jsAddnsToLayout);
        $this->set('jsAddnsToLayout', $this->jsAddnsToLayout);
        
        // Replaces generic flashMessage with customized version that allows
        // use of our CSS classes. Stored in /views/elements/flash_custom.ctp
        if ($this->Session->check('Message.flash')) {
            $flash = $this->Session->read('Message.flash');
            if ($flash['element'] == 'default') {
                $flash['element'] = 'flash_custom';
                $this->Session->write('Message.flash', $flash);
            } else {
                $flash['element'] = 'flash_error';
                $this->Session->write('Message.flash', $flash);
            }
        }

        if ($this->Cookie->check('Ineligible'))
            $this->Cookie->delete('Ineligible');
    }
    /**
     *
     */
    function afterFilter() {

        if ($this->Session->check(SURVEY_SESSION_JUST_FINISHED))
            $this->Session->delete(SURVEY_SESSION_JUST_FINISHED);

        $userid = $this->Auth->user('id');

        if (empty($userid)) {
            $userid = -1;
        }

        // Logging

        // Logging action parameter override
        if (!isset($this->paramsToLog)){
            $paramsToAction = strip_tags(implode(',', $this->request->params['pass']));
            $paramsToAction =
                    $this->_cleanParamsForExternalResourceUrlLogging(
                            $paramsToAction);
        }
        else
            $paramsToAction = $this->paramsToLog;


        $log['Log'] = array(
            "user_id"     =>  $userid,
            "controller"  =>  strip_tags($this->request->params['controller']),
            "action"      =>  strip_tags('end ' . $this->request->params['action']),
            "params"      =>  $paramsToAction,
            "time"        =>  gmdate("Y-m-d G-i-s"),
            "ip_address" => $this->request->clientIp(),
            "user_agent" => $_SERVER['HTTP_USER_AGENT']
        );

        // Log the patient id opportunistically
        if (isset($this->patient['Patient']['id']))
            $log['Log']['patient_id'] = $this->patient['Patient']['id'];

        if (isset($this->patientIdToLog))
            $log['Log']['patient_id'] = $this->patientIdToLog;

        $this->Log->create();
        $this->Log->save($log);
    }


    /**
    * teaching/log_click_to_external_resource is an ajax call
    *   made just for logging the click to open an external resource.
    *   It's params are ugly urls which need to be translated 
    *   a bit to get past the cakephp router
    */
    function _cleanParamsForExternalResourceUrlLogging($paramsToAction){
        if (strstr($paramsToAction, 'PERCENTREPLACEME')){
            $paramsToAction = 
                str_replace('PERCENTREPLACEME', '%', $paramsToAction);
            $paramsToAction = urldecode($paramsToAction);
        }
        return $paramsToAction;
    }


    /**
     * Adds quicklinks to the controller's $quickLinks array. A quick link 
     * is only added if the user is authorized to take the action that it 
     * refers to.  
     *
     * @param $quickLink array $quickLink an array defining the quick links 
     *   to add. Each element will be of the form "link display text" => 
     *   array("controller" => "x", "action" => "y")
     */
    function addToQuickLinks($quickLinksToAdd, $subcategories = false){
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "()", LOG_DEBUG);

        foreach ($quickLinksToAdd as $key => $val) {
            // if not a categorized sub-array
            if (!$subcategories) {

                $ctrlrActn = $this->parseUrlControllerAndAction($val);
                $controller = $ctrlrActn['controller'];
                $action = $ctrlrActn['action'];

                if ($this->DhairAuth->isAuthorizedForUrl($controller,
                                                            $action))
                {
                    $this->quickLinks[$key] = $val;
                }
            }
            // if a categorized sub-array (e.g. for the admin tab)
            else {
                $this->quickLinks[$key] = array();
                foreach($val as $subcat => $url){
                    $ctrlrActn = $this->parseUrlControllerAndAction($url);
                    $controller = $ctrlrActn['controller'];
                    $action = $ctrlrActn['action'];

                    if ($this->DhairAuth->isAuthorizedForUrl($controller,
                                                                $action)){
                        $this->quickLinks[$key][$subcat] = $url;
                    }
                }
                if (sizeof($this->quickLinks[$key]) == 0){
                    unset($this->quickLinks[$key]);
                }
            }
        }
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(), returning", LOG_DEBUG);
    }


    /**
     *
     * TODO move welcome_text assignment here? 
     */
    function initPatientsTabNav(){
        $this->TabFilter->selected_tab("Patients");
        $this->TabFilter->show_normal_tabs();

        if ($this->Session->check('quickLinks') && !empty($_SESSION['quickLinks'])){
            $this->quickLinks = $this->Session->read('quickLinks');
            //$this->log(__CLASS__ . "->" . __FUNCTION__ . "(), Session var quickLinks exists, populated this->quickLinks with it here it is:" . print_r($this->quickLinks, true) , LOG_DEBUG);        
        }
        else {
            //$this->log(__CLASS__ . "->" . __FUNCTION__ . "(), Session var quickLinks does not exist.", LOG_DEBUG);        
            $quickLinks = Configure::read('quickLinks');

            //$this->log(__CLASS__ . "->" . __FUNCTION__ . "(), heres quickLinks from config:" . print_r($quickLinks, true) , LOG_DEBUG);        

          if (!$quickLinks){
            // use these hard-coded defaults
            $quickLinks = array();
        
            $quickLinks["Patients"] = array(
                "View Patient Records" =>
                            array("controller" => "patients",
                                  "action" => "viewAll"),
                "Patient Search" =>
                            array("controller" => "patients",
                                  "action" => "search"),
                "New Patient Record" =>
                            array("controller" => "patients",
                                  "action" => "add")
            );
            $quickLinks["To Do"] = array(
                "Appointment Calendar"=>
                            array("controller" => "patients",
                                  "action" => "calendar"),
                "Check Agains" =>
                            array("controller" => "patients",
                                  "action" => "checkAgainCalendar"),
                "Past Check Agains" =>
                            array("controller" => "patients",
                                  "action" => "noCheckAgain")
            );
            if (!defined('INITIAL_PATIENT_ROLE') ||
                (defined('INITIAL_PATIENT_ROLE') 
                    && INITIAL_PATIENT_ROLE != 'ParticipantTreatment')){
            // if the initial role is treatment (kludgy), no need for consent processes
                $quickLinks["Accrual"]["Accrual Report"] =
                            array("controller" => "patients",
                                  "action" => "accrualReport");
                $quickLinks["Accrual"]["Participant Status Report"] =
                            array("controller" => "patients",
                                  "action" => "offStudy");
                $quickLinks["To Do"]["Consent Verification"] =
                            array("controller" => "patients",
                                  "action" => "consents");
                //"Interested Patients" =>
                //            array("controller" => "patients",
                //                  "action" => "interested_report"),
            }
            $quickLinks["Patients"]["Audio Files"] =
                            array("controller" => "audio_files",
                                  "action" => "viewAll");
            $quickLinks["Patients"]["Chart Coding"] =
                            array("controller" => "charts",
                                  "action" => "viewAll");
            $quickLinks["Clinicians"] = array(
                "View Clinicians" =>
                            array("controller" => "clinicians",
                                  "action" => "viewAll"),
                "New Clinician" =>
                            array("controller" => "clinicians",
                                  "action" => "add"),
                "Clinician Consents" =>
                            array("controller" => "clinicians",
                                  "action" => "consents")
            );
            $quickLinks["Staff"] = array(
                "View Staff Users" =>
                            array("controller" => "admin",
                                  "action" => "viewNonAdminUsers"),
                //"New Staff Record" =>
                //                array("controller" => "admin",
                //                      "action" => "createStaff")
            );
            /**$quickLinks["Change any user's password"] =
                            array("controller" => "admin",
                                  "action" => "pwchange");
            */
            $quickLinks["Kiosk Mode"] = array(
                "Configure browser for kiosk mode" =>
                            array("controller" => "admin",
                                  "action" => "kiosk")
            );
            if ($this->testInstance) {
                $quickLinks["System"]["Manage Test Database"] =
                                array("controller" => "admin",
                                      "action" => "viewDatabaseSnapshots");
            }
          }
            $this->addToQuickLinks($quickLinks, true);
            $this->Session->write('quickLinks', $this->quickLinks);
        }
//        $this->log(__CLASS__ . "->" . __FUNCTION__ . "(), heres quickLinks before set() -ing for view:" . print_r($this->quickLinks, true) , LOG_DEBUG);        

        $this->set('quick_links', $this->quickLinks);
    }// function initPatientsTabNav(){

    /**
     * Check that we haven't timed out since the last request.
     *
     * Note that this function gets called every time an authorized 
     * action is invoked, including users/updateTimeout, which is called
     * via Js every n times a user presses a key or clicks somewhere
     */
    private function checkForTimeout() {

//        $this->log(__CLASS__ . "." . __FUNCTION__ . "()", LOG_DEBUG);
        $lastTime = $this->Session->read(self::TIMEOUT_KEY);
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(), read session to set lastTime = " . $lastTime, LOG_DEBUG);

        $timeoutLength = $this->isKiosk() ? self::KIOSK_TIMEOUT : 
                                            self::NONKIOSK_TIMEOUT;
        $time = time();
 
        if ($lastTime && $time - $lastTime > $timeoutLength) {
//            $this->log(__CLASS__ . "." . __FUNCTION__ . "(), redirecting to /users/logout?timeout=true", LOG_DEBUG);
            # log out current user
            $this->redirect('/users/logout?timeout=true');
        } 

//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(), NOT redirecting to /users/logout?timeout=true", LOG_DEBUG);
        /* 'renew' the session by rewriting the ID_KEY and the timeout */
        $this->Session->write(self::ID_KEY, $this->Session->read(self::ID_KEY));
        $this->Session->write(self::TIMEOUT_KEY, $time);
    }

    /** 
     * Auth's authorize method is set to 'controller', 
     *    so this isAuthorized method is called with every request 
     *    to determine whether the current request is permissable.
     * Note: this is called after the Auth lib determines whether
     *    the login credentials match the User's name/pw
     * Note: this is called after beforeFilter() 
     * Note: this method is not called if the particular request does
     *    not require authorization (as set by Auth->allow() in controllers)
     * @param $user a cakephp array of User and associated table data (ie w/ elems 'User' => array, 'Clinic' => array etc)
     * see also: DhairAuthComponent
     */
    function isAuthorized($user)
    {
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "()", LOG_DEBUG);

//        $this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'] . '; here\'s Auth->user(id): ' . $this->Auth->user('id') . ', here\'s the stack: ' . Debugger::trace(), LOG_DEBUG);
        //$this->log(__CLASS__ . "." . __FUNCTION__ . "() for " . $this->request->params['controller'] . '/' . $this->request->params['action'] . '; here\'s Auth->user(id): ' . $this->Auth->user('id') . ', here\'s the stack: ' . Debugger::trace() . ', and heres the user param: ' . print_r($user, true), LOG_DEBUG);

        //if ($this->DhairAuth->isAuthorizedForUrl($this->request->params['url']['url'])) {
        if ($this->DhairAuth->isAuthorizedForUrl(
                $this->request->params['controller'], $this->request->params['action'])) {
//            $this->log(__CLASS__ . "." . __FUNCTION__ . "() user authorized for url (" . $this->request->params['controller'] . '/' . $this->request->params['action'] . ") so returning true", LOG_DEBUG);
            return true;
        } else {
//            $this->log(__CLASS__ . "." . __FUNCTION__ . "() user not authorized for url (" . $this->request->params['controller'] . '/' . $this->request->params['action'] . ") so redirecting to /users/", LOG_DEBUG);
            if ($this->is_staff){
                if ($this->DhairAuth->isAuthorizedForUrl('patients', 'calendar'))
                    $this->redirect(array('controller'=>'patients', 'action'=>'calendar'));
                else
                    $this->redirect(array('controller'=>'users', 'action'=>'help'));
            }
            else
                $this->redirect(array('controller'=>'users'));
            return false;
        }
    }


  /*
  *  check whether a controller / action combo is used by this DHAIR instance
  *
  */
  function isUsedByThisDhairInstance($controller, $action){

    if (in_array($controller, $this->modelsForThisDhairInstance)){
        //$this->log("isUsedByThisDhairInstance($controller, $action), ", LOG_DEBUG);
        return true;
    }

    else{
        //$this->log("isUsedByThisDhairInstance($controller, $action), returning false" . Debugger::trace(), LOG_DEBUG);
        return false;
    }

  }

  /**
    Break up a url and get relevant pieces. 
    Cake may eventually have a parse url function, in which case we should 
    use that to make sure this has the same defaults as the system does.
  */
  function parseUrlControllerAndAction($url) {

      if(is_array($url)) {
          $url_parts = array($url['controller'], $url['action']);
      } else {
          if ($url[0] == "/") {
              $url = substr($url, 1);
          }
          $url_parts = split("/", $url);
      }
      $controller = $url_parts[0];
      if ($controller == '')  $controller = 'users';
      //$this->log("controller: " . $controller , LOG_DEBUG);

      # catch cases like "/users" or "/users/" that really mean "/users/index"
      if(count($url_parts) > 1 && $url_parts[1] != "") {
          $action = $url_parts[1];
      } else {
          $action = "index";
      }
      //$this->log("action: " . $action , LOG_DEBUG);

    return array('controller' => $controller, 'action' => $action);
  }


    /** 
     * Are we running in kiosk mode?
     * @return boolean, 
     * It would be safer to return true if cookie's not found (for safety eg in case user deleted it), but it would be a bit more work to manage that carefully enough so new patients aren't put in kiosk mode. 
     */
    function isKiosk()
    {
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(), here's Kiosk cookie: " . $this->Cookie->read('Kiosk'), LOG_DEBUG);
        if ($this->Cookie->read('Kiosk') == "true") { 
//            $this->log(__CLASS__ . "." . __FUNCTION__ . "(), returning true", LOG_DEBUG);
            return true;
        } else {
//            $this->log(__CLASS__ . "." . __FUNCTION__ . "(), returning false", LOG_DEBUG);
            return false;
        }
    }

    /** Set the kiosk mode
     * @param kiosk boolean
     */
    # saved in the cookie as the string "true" or "false"
    function setKiosk($kiosk)
    {
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(" . $kiosk . ")", LOG_DEBUG);
        if($kiosk == "true") {
            // $this->log("writing true", LOG_DEBUG);
            $this->Cookie->write('Kiosk', "true");
        } else {
            // $this->log("writing false", LOG_DEBUG);
            $this->Cookie->write('Kiosk', "false");
        }
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(), just set Kiosk cookie, here it is: " . $this->Cookie->read('Kiosk'), LOG_DEBUG);
    }

   /** 
    * Delete session variables on logout.  Used by both users/logout
    * and patients/loginAs
    * This used to be more complex than a single fxn call... 
    *   keeping it as a shell fxn in case we need to add more to it
    */
   function deleteVariablesOnLogout() {

        // Sessions are bound to the client system (IP and user agent),
        //  but not to Auth->user. Destroying the session to avoid
        //  cross-user sessions when users share client systems.   
        $this->Session->destroy();
   }

/**
*   a la dhair1 p4
*   this is used for non-DB dhair strings
*       FIXME NOT USED IN APP . 'Controller' . DS YET, BUT WHEN IT IS IT SHOULD BE IN A COMPONENT
*   Most likely deprecated, user __() function instead
*/

  function i18nString($string) {

    if ($this->i18nPostfix === "_es_MX"){
        $handle = fopen(APP . "config" . DS . "i18nForPhp.csv", "r");
        while (($data = fgetcsv($handle, 1000, ",")) !== FALSE) {

            if ((count($data) == 2) && ($data[0] === $string)){
                fclose($handle);
                return $data[1];
            }
        }
        return $string . " (No match in translation file)";
    }
    else return $string;
  }


    /**
     *
     */
    protected function getSubdomain(){
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "()", LOG_DEBUG);


        $subdomain = '';
        // REQUEST_URI eg "/rural/users/changePasswordOfAuthdUser"
        $controllerPosn = strpos($_SERVER['REQUEST_URI'], 
                                    $this->request->params['controller']);

        if ($controllerPosn != 1){
            $subdomain = substr($_SERVER['REQUEST_URI'], 1, $controllerPosn -2);
        } 

        
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(), returning $subdomain", LOG_DEBUG);
        return $subdomain;
    } 

    /** 
     *   accommodate instance specific action (eg clinician_report_sarcoma)
     */
    public function actionNameWithoutInstanceId($action = null) {
//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(), heres action: " . $this->request->params['action'] . "; this is for controller: " . $this->request->params['controller'], LOG_DEBUG);

        if ($action){
            $returnVal = $action;
        }
        else
            $returnVal = $this->request->params['action'];
            
        $returnVal = str_replace('_' . INSTANCE_ID, '', $returnVal);

//        $this->log(__CLASS__ . "." . __FUNCTION__ . "(), returning $returnVal", LOG_DEBUG);
        return $returnVal;
    }

}
